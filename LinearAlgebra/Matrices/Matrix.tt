<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#
	var supportedDimensions = new List<int[]> { 
		new int[2] { 1, 1 },
		new int[2] { 2, 2 },
		new int[2] { 3, 3 },
		new int[2] { 4, 4 },
		new int[2] { 1, 2 }, new int[2] { 2, 1 },
		new int[2] { 1, 3 }, new int[2] { 3, 1 },
		new int[2] { 1, 4 }, new int[2] { 4, 1 },
		new int[2] { 2, 3 }, new int[2] { 3, 2 },
		new int[2] { 2, 4 }, new int[2] { 4, 2 },
		new int[2] { 3, 4 }, new int[2] { 4, 3 }
	};
	var componentName = new Func<int, int, string>((x, y) => "e" + x + y);
	var vectorComponentName = new Func<int, int, string>((n, i) => n < 5 ? "xyzw"[i].ToString() : "v" + i);
	var index = 0;
#>
using LinearAlgebra.Vectors;
using LinearAlgebra.Scalars;
using System;
using System.Collections;
using System.Collections.Generic;

namespace LinearAlgebra.Matrices
{
<# foreach (var n in supportedDimensions) { #>
    public struct Matrix<#= n[0] #>x<#= n[1] #><T> : ICloneable, IEquatable<Matrix<#= n[0] #>x<#= n[1] #><T>>, IEnumerable, IEnumerable<Scalar<T>>, IEnumerable<T>, IMatrix<T>
        where T : struct, IComparable
    {
        public readonly Scalar<T> <#= string.Join(", ", Enumerable.Range(0, n[0]).Select(x => string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "e" + x + y)))) #>;

        public Vector2<int> Dimensions => new Vector2<int>(<#= n[0] #>, <#= n[1] #>);

        public Scalar<T>[,] Data => new Scalar<T>[<#= n[0] #>, <#= n[1] #>] {
<# for(int x = 0; x < n[0]; x++) { #>
            { <#= string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "e" + x + y)) #> }<#= x < n[0] - 1 ? "," : "" #>
<# } #>
        };

        public static Matrix<#= n[0] #>x<#= n[1] #><T> Zero()
        {
            return new Matrix<#= n[0] #>x<#= n[1] #><T>(<#= string.Join(", ", Enumerable.Range(0, n[0] * n[1]).Select(x => "0")) #>);
        }

<# if (n[0] == n[1]) { #>
        public static Matrix<#= n[0] #>x<#= n[1] #><T> One()
        {
            return new Matrix<#= n[0] #>x<#= n[1] #><T>(<#= string.Join(", ", Enumerable.Range(0, n[0]).Select(x => string.Join(", ", Enumerable.Range(0, n[1]).Select(y => x == y ? "1" : "0")))) #>);
        }

<# } #>
        public Matrix<#= n[0] #>x<#= n[1] #>(<#= string.Join(", ", Enumerable.Range(0, n[0]).Select(x => string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "Scalar<T> e" + x + y)))) #>)
        {
<# for(int x = 0; x < n[0]; x++) { #>
<# for(int y = 0; y < n[1]; y++) { #>
            this.e<#= x + "" + y #> = e<#= x + "" + y #>;
<# } #>
<# } #>
        }

        public Matrix<#= n[0] #>x<#= n[1] #>(<#= string.Join(", ", Enumerable.Range(0, n[0]).Select(x => string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "T e" + x + y)))) #>)
        {
<# for(int x = 0; x < n[0]; x++) { #>
<# for(int y = 0; y < n[1]; y++) { #>
            this.e<#= x + "" + y #> = new Scalar<T>(e<#= x + "" + y #>);
<# } #>
<# } #>
        }

        public Scalar<T> this[int i, int j] => Data[i, j];

        public Vector<#= n[1] #><T>[] Rows
        {
            get
            {
                return new Vector<#= n[1] #><T>[]
                {
<# for(int x = 0; x < n[0]; x++) { #>
                    new Vector<#= n[1] #><T>(<#= string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "e" + x + y)) #>)<#= x < n[0] - 1 ? "," : "" #>
<# } #>
                };
            }
        }

        public Vector<#= n[0] #><T>[] Columns
        {
            get
            {
                return new Vector<#= n[0] #><T>[]
                {
<# for(int x = 0; x < n[1]; x++) { #>
                    new Vector<#= n[0] #><T>(<#= string.Join(", ", Enumerable.Range(0, n[0]).Select(y => "e" + y + x)) #>)<#= x < n[1] - 1 ? "," : "" #>
<# } #>
                };
            }
        }

        public Vector<#= n[0] #><T> Transform(Vector<#= n[1] #><T> vec)
        {
            return new Vector<#= n[0] #><T>(
<# for(int x = 0; x < n[0]; x++) { #>
                <#= string.Join(" + ", Enumerable.Range(0, n[1]).Select(y => "e" + x + y + " * vec." + vectorComponentName(n[0], y))) #><#= x < n[0] - 1 ? "," : "" #>
<# } #>
            );
        }

        public Matrix1x<#= n[0] #><T> Transform(Matrix<#= n[1] #>x1<T> mat)
        {
            return new Matrix1x<#= n[0] #><T>(
<# for(int x = 0; x < n[0]; x++) { #>
                <#= string.Join(" + ", Enumerable.Range(0, n[1]).Select(y => "e" + x + y + " * mat." + componentName(y, 0))) #><#= x < n[0] - 1 ? "," : "" #>
<# } #>
            );
        }

        public Matrix<#= n[1] #>x<#= n[0] #><T> Transpose()
        {
            return new Matrix<#= n[1] #>x<#= n[0] #><T>(
<# for(int y = 0; y < n[1]; y++) { #>
                <#= string.Join(", ", Enumerable.Range(0, n[0]).Select(x => "e" + x + y)) #><#= y < n[1] - 1 ? "," : "" #>
<# } #>
            );
        }

        public static Vector<#= n[0] #><T> operator *(Matrix<#= n[0] #>x<#= n[1] #><T> left, Vector<#= n[1] #><T> right)
        {
            return new Vector<#= n[0] #><T>(
<# for(int x = 0; x < n[0]; x++) { #>
                <#= string.Join(" + ", Enumerable.Range(0, n[1]).Select(y => "left.e" + x + y + " * right." + vectorComponentName(n[0], y))) #><#= x < n[0] - 1 ? "," : "" #>
<# } #>
            );
        }

        public static Matrix<#= n[0] #>x<#= n[1] #><T> operator +(Matrix<#= n[0] #>x<#= n[1] #><T> left, Matrix<#= n[0] #>x<#= n[1] #><T> right)
        {
            return new Matrix<#= n[0] #>x<#= n[1] #><T>(
<# for(int x = 0; x < n[0]; x++) { #>
                <#= string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "left.e" + x + y + " + right.e" + x + y)) #><#= x < n[0] - 1 ? "," : "" #>
<# } #>
            );
        }

        public static Matrix<#= n[0] #>x<#= n[1] #><T> operator -(Matrix<#= n[0] #>x<#= n[1] #><T> left, Matrix<#= n[0] #>x<#= n[1] #><T> right)
        {
            return new Matrix<#= n[0] #>x<#= n[1] #><T>(
<# for(int x = 0; x < n[0]; x++) { #>
                <#= string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "left.e" + x + y + " - right.e" + x + y)) #><#= x < n[0] - 1 ? "," : "" #>
<# } #>
            );
        }

        public static Matrix<#= n[0] #>x<#= n[1] #><T> operator *(Scalar<T> left, Matrix<#= n[0] #>x<#= n[1] #><T> right)
        {
            return new Matrix<#= n[0] #>x<#= n[1] #><T>(
<# for(int x = 0; x < n[0]; x++) { #>
                <#= string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "left * right.e" + x + y)) #><#= x < n[0] - 1 ? "," : "" #>
<# } #>
            );
        }

        public static Matrix<#= n[0] #>x<#= n[1] #><T> operator *(Matrix<#= n[0] #>x<#= n[1] #><T> left, Scalar<T> right)
        {
            return right * left;
        }

        public static Matrix<#= n[0] #>x<#= n[1] #><T> operator /(Scalar<T> left, Matrix<#= n[0] #>x<#= n[1] #><T> right)
        {
            return new Matrix<#= n[0] #>x<#= n[1] #><T>(
<# for(int x = 0; x < n[0]; x++) { #>
                <#= string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "left / right.e" + x + y)) #><#= x < n[0] - 1 ? "," : "" #>
<# } #>
            );
        }

        public static Matrix<#= n[0] #>x<#= n[1] #><T> operator /(Matrix<#= n[0] #>x<#= n[1] #><T> left, Scalar<T> right)
        {
            return new Matrix<#= n[0] #>x<#= n[1] #><T>(
<# for(int x = 0; x < n[0]; x++) { #>
                <#= string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "left.e" + x + y + " / right")) #><#= x < n[0] - 1 ? "," : "" #>
<# } #>
            );
        }

        public static Matrix<#= n[0] #>x<#= n[1] #><T> operator -(Matrix<#= n[0] #>x<#= n[1] #><T> m)
        {
            return new Matrix<#= n[0] #>x<#= n[1] #><T>(
<# for(int x = 0; x < n[0]; x++) { #>
                <#= string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "-m.e" + x + y)) #><#= x < n[0] - 1 ? "," : "" #>
<# } #>
            );
        }

<# if (n[0] > 1 && n[1] > 1) { #>
        public static implicit operator Matrix<#= n[0] #>x<#= n[1] #><T>((<#= string.Join(", ", Enumerable.Range(0, n[0]).Select(x => "(" + string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "T")) + ")" )) #>) t)
        {
            return new Matrix<#= n[0] #>x<#= n[1] #><T>(
<# for(int x = 0; x < n[0]; x++) { #>
                <#= string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "t.Item" + (x + 1) + ".Item" + (y + 1))) #><#= x < n[0] - 1 ? "," : "" #>
<# } #>
            );
        }

<# } #>
        public override string ToString()
        {
            return $"Matrix<#= n[0] #>x<#= n[1] #>(" + Environment.NewLine +
<# for(int x = 0; x < n[0]; x++) { #>
                    $"\t(<#= string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "{ e" + x + y + " }")) #>)<#= x < n[0] - 1 ? "," : "" #>" + Environment.NewLine +
<# } #>
                $")";
        }

        public override bool Equals(object obj)
        {
            if (obj is Matrix<#= n[0] #>x<#= n[1] #><T> m)
                return Equals(m);

            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public object Clone()
        {
            return new Matrix<#= n[0] #>x<#= n[1] #><T>(<#= string.Join(", ", Enumerable.Range(0, n[0]).Select(x => string.Join(", ", Enumerable.Range(0, n[1]).Select(y => "e" + x + y)))) #>);
        }

        public bool Equals(Matrix<#= n[0] #>x<#= n[1] #><T> other)
        {
            return <#= string.Join(" && ", Enumerable.Range(0, n[0]).Select(x => string.Join(" && ", Enumerable.Range(0, n[1]).Select(y => "e" + x + y + " == other.e" + x + y)))) #>;
        }

        public IEnumerator GetEnumerator()
        {
            return GetEnumerator();
        }

        IEnumerator<Scalar<T>> IEnumerable<Scalar<T>>.GetEnumerator()
        {
<# for(int x = 0; x < n[0]; x++) { #>
<# for(int y = 0; y < n[1]; y++) { #>
            yield return e<#= x + "" + y #>;
<# } #>
<# } #>
        }

        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
<# for(int x = 0; x < n[0]; x++) { #>
<# for(int y = 0; y < n[1]; y++) { #>
            yield return e<#= x + "" + y #>.Value;
<# } #>
<# } #>
        }
    }
<# index++; if (index != supportedDimensions.Count) { #>

<# } #>
<# } #>
}