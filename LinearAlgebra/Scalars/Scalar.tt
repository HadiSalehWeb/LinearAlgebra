<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#
	List<ScalarType> supportedTypes = new List<ScalarType> {
		new ScalarType(typeof(sbyte), "(sbyte)0", "(sbyte)1", "(sbyte)-128", "(sbyte)127", true, false),
		new ScalarType(typeof(byte), "(byte)0", "(byte)1", "(byte)0", "(byte)255", false, false),
		new ScalarType(typeof(short), "(short)0", "(short)1", "(short)-32768", "(short)32767", true, false),
		new ScalarType(typeof(ushort), "(ushort)0", "(ushort)1", "(ushort)0", "(ushort)65535", false, false),
		new ScalarType(typeof(int), "0", "1", "-2147483648", "2147483647", true, false),
		new ScalarType(typeof(uint), "0u", "1u", "0u", "4294967295u", false, false),
		new ScalarType(typeof(long), "0L", "1L", "-9223372036854775808L", "9223372036854775807L", true, false),
		new ScalarType(typeof(ulong), "0uL", "1uL", "0uL", "18446744073709551615uL", false, false),
		new ScalarType(typeof(float), "0f", "1f", "-3.40282347E+38f", "3.40282347E+38f", true, true),
		new ScalarType(typeof(double), "0d", "1d", "-1.7976931348623157E+308d", "1.7976931348623157E+308d", true, true),
		new ScalarType(typeof(decimal), "0m", "1m", "-79228162514264337593543950335m", "79228162514264337593543950335m", true, true),
	};
	
	Func<string, string> getFieldName = new Func<string, string>(name => char.ToLower(name[0]) + name.Substring(1) + "Value");
	Func<string, string> getPropertyName = new Func<string, string>(name => name + "Value");
#>
using System;
using LinearAlgebra.Vectors;
using System.Collections.Generic;
using System.Runtime.InteropServices;

// This file was automatically generated by 'Scalar.tt'. Make edits to the t4 file instead of this.

/* Note
 * Scalars are supposed to be elements of a field*, but some types (int, ushort etc.) can't form 
 * fields because a) they don't have an additive inverse or b) don't have a multiplicative inverse.
 * This means a lot of run-time type checking and exception throwing and rounding might happen if they're
 * used in the wrong context (eg. the magnitude of an integer vector will be rounded).
 * 
 * Field: https://en.wikipedia.org/wiki/Field_(mathematics)
 */

namespace LinearAlgebra.Scalars
{
    /// <summary>
    /// This is where the magic happens.
    /// The purpose of this struct is to replicate the behaviour of a union type in C by lining up all its
    /// fields in the same memory address, since only one of them will end up being used at a time.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    struct TypedValueContainer
    {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
        [FieldOffset(0)]
        public readonly <#= supportedTypes[i].type.ToString() #> <#= getFieldName(supportedTypes[i].name) #>;
<# } #>

        public TypedValueContainer(<#= string.Join(", ", supportedTypes.Select(x => x.type.ToString() + " " + getFieldName(x.name))) #>)
        {
            //All values must be initialized to zero at first because they're readonly, and the actual value 
            //is assigned at the very end to ensure it's not overwritten (see FieldOffsetAttribute)
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
            <#= i == 0 ? "if" : "else if" #> (<#= getFieldName(supportedTypes[i].name) #> != default)
            {
<# for (int j = 0; j < supportedTypes.Count; j++) { #>
<# if (i != j) { #>
                this.<#= getFieldName(supportedTypes[j].name) #> = default;
<# } #>
<# } #>
                this.<#= getFieldName(supportedTypes[i].name) #> = <#= getFieldName(supportedTypes[i].name) #>;
            }
<# } #>
            else
            {
<# for (int j = 0; j < supportedTypes.Count; j++) { #>
                this.<#= getFieldName(supportedTypes[j].name) #> = default;
<# } #>
            }
        }
    }

    /// <typeparam name="T"><#= string.Join(", ", supportedTypes.Select(x => x.name)) #></typeparam>
    [Serializable]
    public struct Scalar<T> : ITensor<T, Vector0<int>, Scalar<T>>
        where T : struct
    {
        #region Type Handling

        private enum ScalarType
        {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
            <#= supportedTypes[i].name #><#= i < supportedTypes.Count - 1 ? "," : "" #>
<# } #>
        }

        public enum AlgebraicStructure
        {
            Semiring = 1,
            Ring = 3,
            Field = 7
        }

        private static readonly Dictionary<Type, ScalarType> TypeMap = new Dictionary<Type, ScalarType>
        {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
            { typeof(<#= supportedTypes[i].type.ToString() #>), ScalarType.<#= supportedTypes[i].name #> }<#= i < supportedTypes.Count - 1 ? "," : "" #>
<# } #>
        };

        private static readonly ScalarType scalarType;

        public static readonly AlgebraicStructure algebraicStructure;

        #endregion

        #region Fields and Properties

        public static Scalar<int> Order => Scalar<int>.Zero;
        public Vector0<int> Dimension => Vector0<int>.zero;

        private readonly TypedValueContainer tvc;

<# for (int i = 0; i < supportedTypes.Count; i++) { #>
        private <#= supportedTypes[i].type.ToString() #> <#= getPropertyName(supportedTypes[i].name) #> => tvc.<#= getFieldName(supportedTypes[i].name) #>;
<# } #>

        public T Value { get; }

        #endregion

        #region Static

        public static Scalar<T> Zero { get; }
        public static Scalar<T> One { get; }
        public static Scalar<T> MinValue { get; }
        public static Scalar<T> MaxValue { get; }

        static Scalar()
        {
            if (!TypeMap.TryGetValue(typeof(T), out scalarType))
                throw new ArgumentException($"Type <{ typeof(T).Name }> not supported for scalar values.");

            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
                    Zero = <#= supportedTypes[i].zeroValue #>;
                    One = <#= supportedTypes[i].oneValue #>;
                    MinValue = <#= supportedTypes[i].minValue #>;
                    MaxValue = <#= supportedTypes[i].maxValue #>;
                    algebraicStructure = AlgebraicStructure.<#= supportedTypes[i].algebraicStructreName #>;
                    break;
<# } #>
                default:
                    throw new ArgumentException($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        #endregion

        #region Constructors

        public Scalar(T value)
        {
            Value = value;

<# for (int i = 0; i < supportedTypes.Count; i++) { #>
            <#= i == 0 ? "if" : "else if" #> (value is <#= supportedTypes[i].type.ToString() #> <#= getFieldName(supportedTypes[i].name) + "T" #>)
                tvc = new TypedValueContainer(<#= string.Join(", ", supportedTypes.Select((x, j) => j == i ? getFieldName(x.name) + "T" : "default")) #>);
<# } #>
            else
                throw new ArgumentException($"Type <{ typeof(T).Name }> not supported for scalar values.");
        }

        static Scalar<T> From<U>(U u) where U : struct
        {
            if (u is T t)
                return new Scalar<T>(t);
            if (u is IConvertible ic)
                return new Scalar<T>((T)ic.ToType(typeof(T), null));

            else throw new ArgumentException($"Type <{ typeof(U).Name }> cannot be converted to type <{ typeof(T).Name }>.");
        }

        #endregion

        #region Functions

        public Scalar<U> Cast<U>()
            where U : struct
        {
            if (Value is U u)
                return new Scalar<U>(u);
            if (Value is IConvertible ic)
                return new Scalar<U>((U)ic.ToType(typeof(U), null));

            else throw new ArgumentException($"Type <{ typeof(U).Name }> cannot be converted to type <{ typeof(T).Name }>.");
        }

        #endregion

        #region Operators

        #region Arithmetic

        public Scalar<T> Add(Scalar<T> s)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
                    return From(<#= getPropertyName(supportedTypes[i].name) #> + s.<#= getPropertyName(supportedTypes[i].name) #>);
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static Scalar<T> operator +(Scalar<T> left, Scalar<T> right)
        {
            return left.Add(right);
        }

        public Scalar<T> Substract(Scalar<T> s)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
                    return From(<#= getPropertyName(supportedTypes[i].name) #> - s.<#= getPropertyName(supportedTypes[i].name) #>);
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static Scalar<T> operator -(Scalar<T> left, Scalar<T> right)
        {
            return left.Substract(right);
        }

        public Scalar<T> Multiply(Scalar<T> s)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
                    return From(<#= getPropertyName(supportedTypes[i].name) #> * s.<#= getPropertyName(supportedTypes[i].name) #>);
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public Scalar<T> Scale(Scalar<T> s)
        {
            return Multiply(s);
        }

        public static Scalar<T> operator *(Scalar<T> left, Scalar<T> right)
        {
            return left.Multiply(right);
        }

        public Scalar<T> Divide(Scalar<T> s)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
                    return From(<#= getPropertyName(supportedTypes[i].name) #> / s.<#= getPropertyName(supportedTypes[i].name) #>);
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public Scalar<T> GetDividedBy(Scalar<T> s)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
                    return From(s.<#= getPropertyName(supportedTypes[i].name) #> / <#= getPropertyName(supportedTypes[i].name) #>);
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public Scalar<T> Reciprocal()
        {
            return GetDividedBy(One);
        }

        public static Scalar<T> operator /(Scalar<T> left, Scalar<T> right)
        {
            return left.Divide(right);
        }

        public Scalar<T> Negate()
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
<# if (supportedTypes[i].hasAdditiveInverse) { #>
                    return From(-<#= getPropertyName(supportedTypes[i].name) #>);
<# } else { #>
                    throw new Exception("Type <<#= supportedTypes[i].type.ToString() #>> cannot be negated.");
<# } #>
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static Scalar<T> operator -(Scalar<T> t)
        {
            return t.Negate();
        }

        #endregion

        #region Identity and Order

        public static bool operator ==(Scalar<T> left, Scalar<T> right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(Scalar<T> left, Scalar<T> right)
        {
            return !left.Equals(right);
        }

        public static bool operator <(Scalar<T> left, Scalar<T> right)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
                    return left.<#= getPropertyName(supportedTypes[i].name) #>.CompareTo(right.<#= getPropertyName(supportedTypes[i].name) #>) < 0;
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static bool operator >(Scalar<T> left, Scalar<T> right)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
                    return left.<#= getPropertyName(supportedTypes[i].name) #>.CompareTo(right.<#= getPropertyName(supportedTypes[i].name) #>) > 0;
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static bool operator <=(Scalar<T> left, Scalar<T> right)
        {
            return (left < right) || (left == right);
        }

        public static bool operator >=(Scalar<T> left, Scalar<T> right)
        {
            return (left > right) || (left == right);
        }

        #endregion

        #endregion

        #region Implicit Conversion

<# for (int i = 0; i < supportedTypes.Count; i++) { #>
        public static implicit operator Scalar<T>(<#= supportedTypes[i].type.ToString() #> value)
        {
            return From(value);
        }
        public static implicit operator <#= supportedTypes[i].type.ToString() #>(Scalar<T> value)
        {
            if (scalarType == ScalarType.<#= supportedTypes[i].name #>)
                return value.<#= getPropertyName(supportedTypes[i].name) #>;
            return value.Cast<<#= supportedTypes[i].type.ToString() #>>().Value;
        }

<# } #>
        #endregion

        #region Interface Implementations

        public override string ToString()
        {
            return Value.ToString();
        }

        public override bool Equals(object obj)
        {
            if (obj is Scalar<T> sc)
                return Value.Equals(sc.Value);
            if (obj is T t)
                return Value.Equals(t);

            return false;
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public object Clone()
        {
            return new Scalar<T>(Value);
        }

        public bool Equals(Scalar<T> other)
        {
            return Value.Equals(other.Value);
        }

        #endregion
    }
}
<#+
public struct ScalarType
{
	public readonly Type type;
	public readonly string name;
	public readonly string zeroValue;
	public readonly string oneValue;
	public readonly string minValue;
	public readonly string maxValue;
	public readonly bool hasAdditiveInverse;// false for unsigned types, true otherwise
	public readonly bool hasMultiplicativeInverse;// false for types without a decimal point like int, byte, long etc., true otherwise e.g. float, double, decimal.
    public readonly string algebraicStructreName;

	public ScalarType
	(
		Type type,
		string zeroValue,
		string oneValue,
		string minValue,
		string maxValue,
		bool hasAdditiveInverse,
		bool hasMultiplicativeInverse
	)
	{
		this.type = type;
		this.name = type.Name;
		this.zeroValue = zeroValue;
		this.oneValue = oneValue;
		this.minValue = minValue;
		this.maxValue = maxValue;
		this.hasAdditiveInverse = hasAdditiveInverse;
		this.hasMultiplicativeInverse = hasMultiplicativeInverse;

		if (!hasAdditiveInverse && !hasMultiplicativeInverse)
            algebraicStructreName = "Semiring";
        else if (hasAdditiveInverse)
            algebraicStructreName = "Ring";
        else
            algebraicStructreName = "Field";
	}
}
#>