<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#
	List<ScalarType> supportedTypes = new List<ScalarType> {
		new ScalarType(typeof(bool), "false", "true", false, false, false, false, (x, y) => x + " || " + y,  (x, y) => x + " && " + y, complementOverride: x => "!" + x),
		new ScalarType(typeof(sbyte), "(sbyte)0", "(sbyte)1", true, false),
		new ScalarType(typeof(byte), "(byte)0", "(byte)1", false, false),
		new ScalarType(typeof(short), "(short)0", "(short)1", true, false),
		new ScalarType(typeof(ushort), "(ushort)0", "(ushort)1", false, false),
		new ScalarType(typeof(int), "0", "1", true, false),
		new ScalarType(typeof(uint), "0u", "1u", false, false),
		new ScalarType(typeof(long), "0L", "1L", true, false),
		new ScalarType(typeof(ulong), "0uL", "1uL", false, false),
		new ScalarType(typeof(float), "0f", "1f", true, true, canBeComplemented: false),
		new ScalarType(typeof(double), "0d", "1d", true, true, canBeComplemented: false),
		new ScalarType(typeof(decimal), "0m", "1m", true, true, canBeComplemented: false),
	};
	
	Func<string, string> getFieldName = new Func<string, string>(name => char.ToLower(name[0]) + name.Substring(1) + "Value");
	Func<string, string> getPropertyName = new Func<string, string>(name => name + "Value");
#>
using System;
using LinearAlgebra.Vectors;
using System.Collections.Generic;
using System.Runtime.InteropServices;

// This file was automatically generated by 'Scalar.tt'. Make edits to the t4 file instead of this.

/* Note
 * Scalars are supposed to be elements of a field*, but some types (int, bool, ushort etc.) can't form 
 * fields because a) they don't have an additive inverse or b) don't have a multiplicative inverse.
 * This means a lot of run-time type checking and exception throwing and rounding might happen if they're
 * used in the wrong context (eg. the magnitude of an integer vector will be rounded).
 * 
 * Field: https://en.wikipedia.org/wiki/Field_(mathematics)
 */

namespace LinearAlgebra.Scalars
{
    /// <summary>
    /// This is where the magic happens.
    /// The purpose of this struct is to replicate the behaviour of a union type in C by lining up all its
    /// fields in the same memory address, since only one of them will end up being used at a time.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    struct TypedValueContainer
    {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
        [FieldOffset(0)]
        public readonly <#= supportedTypes[i].type.ToString() #> <#= getFieldName(supportedTypes[i].name) #>;
<# } #>

        public TypedValueContainer(<#= string.Join(", ", supportedTypes.Select(x => x.type.ToString() + " " + getFieldName(x.name))) #>)
        {
            //All values must be initialized to zero at first because they're readonly, and the actual value 
            //is assigned at the very end to ensure it's not overwritten (see FieldOffsetAttribute)
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
            <#= i == 0 ? "if" : "else if" #> (<#= getFieldName(supportedTypes[i].name) #> != default)
            {
<# for (int j = 0; j < supportedTypes.Count; j++) { #>
<# if (i != j) { #>
                this.<#= getFieldName(supportedTypes[j].name) #> = default;
<# } #>
<# } #>
                this.<#= getFieldName(supportedTypes[i].name) #> = <#= getFieldName(supportedTypes[i].name) #>;
            }
<# } #>
            else
            {
<# for (int j = 0; j < supportedTypes.Count; j++) { #>
                this.<#= getFieldName(supportedTypes[j].name) #> = default;
<# } #>
            }
        }
    }

    /// <typeparam name="T"><#= string.Join(", ", supportedTypes.Select(x => x.type.Name)) #></typeparam>
    [Serializable]
    public struct Scalar<T> : ICloneable, IEquatable<Scalar<T>>, ITensor<T, Vector0<int>, Scalar<T>>
        where T : struct
    {
        #region Type Handling

        private enum ScalarType
        {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
            <#= supportedTypes[i].name #><#= i < supportedTypes.Count - 1 ? "," : "" #>
<# } #>
        }

        public enum AlgebraicStructure
        {
            BooleanAlgebra,
            Semiring,
            Ring,
            Field
        }

        private static readonly Dictionary<Type, ScalarType> TypeMap = new Dictionary<Type, ScalarType>
        {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
            { typeof(<#= supportedTypes[i].type.ToString() #>), ScalarType.<#= supportedTypes[i].name #> }<#= i < supportedTypes.Count - 1 ? "," : "" #>
<# } #>
        };

        private static readonly ScalarType scalarType;

        public static readonly AlgebraicStructure algebraicStructure;

        #endregion

        #region Fields and Properties

        public Scalar<int> Rank => Scalar<int>.Zero;
        public Vector0<int> Dimension => Vector0<int>.zero;

        private readonly TypedValueContainer tvc;

<# for (int i = 0; i < supportedTypes.Count; i++) { #>
        private <#= supportedTypes[i].type.ToString() #> <#= getPropertyName(supportedTypes[i].name) #> => tvc.<#= getFieldName(supportedTypes[i].name) #>;
<# } #>

        public T Value { get; }

        #endregion

        #region Static

        public static Scalar<T> Zero { get; }
        public static Scalar<T> One { get; }

        static Scalar()
        {
            if (!TypeMap.TryGetValue(typeof(T), out scalarType))
                throw new ArgumentException($"Type <{ typeof(T).Name }> not supported for scalar values.");

            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
                    Zero = <#= supportedTypes[i].zeroValue #>;
                    One = <#= supportedTypes[i].oneValue #>;
                    algebraicStructure = AlgebraicStructure.<#= supportedTypes[i].algebraicStructreName #>;
                    break;
<# } #>
                default:
                    throw new ArgumentException($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        #endregion

        #region Constructors

        public Scalar(T value)
        {
            Value = value;

<# for (int i = 0; i < supportedTypes.Count; i++) { #>
            <#= i == 0 ? "if" : "else if" #> (value is <#= supportedTypes[i].type.ToString() #> <#= getFieldName(supportedTypes[i].name) + "T" #>)
                tvc = new TypedValueContainer(<#= string.Join(", ", supportedTypes.Select((x, j) => j == i ? getFieldName(x.name) + "T" : "default")) #>);
<# } #>
            else
                throw new ArgumentException($"Type <{ typeof(T).Name }> not supported for scalar values.");
        }

        static Scalar<T> From<U>(U u) where U : struct
        {
            if (u is T t)
                return new Scalar<T>(t);
            if (u is IConvertible ic)
                return new Scalar<T>((T)ic.ToType(typeof(T), null));

            else throw new ArgumentException($"Type <{ typeof(U).Name }> cannot be converted to type <{ typeof(T).Name }>.");
        }

        #endregion

        #region Functions

        public Scalar<U> Cast<U>()
            where U : struct
        {
            if (Value is U u)
                return new Scalar<U>(u);
            if (Value is IConvertible ic)
                return new Scalar<U>((U)ic.ToType(typeof(U), null));

            else throw new ArgumentException($"Type <{ typeof(U).Name }> cannot be converted to type <{ typeof(T).Name }>.");
        }

        #endregion

        #region Operators

        #region Arithmetic

        public static Scalar<T> operator +(Scalar<T> left, Scalar<T> right)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
<# if (supportedTypes[i].additionOverride != null) { #>
                    return From(<#= supportedTypes[i].additionOverride("left." + getPropertyName(supportedTypes[i].name), "right." + getPropertyName(supportedTypes[i].name)) #>);
<# } else { #>
                    return From(left.<#= getPropertyName(supportedTypes[i].name) #> + right.<#= getPropertyName(supportedTypes[i].name) #>);
<# } #>
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static Scalar<T> operator -(Scalar<T> left, Scalar<T> right)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
<# if (supportedTypes[i].canBeSubstracted) { #>
                    return From(left.<#= getPropertyName(supportedTypes[i].name) #> - right.<#= getPropertyName(supportedTypes[i].name) #>);
<# } else { #>
                    throw new Exception($"Substraction can't be performed on type <#= supportedTypes[i].type.ToString() #>.");
<# } #>
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static Scalar<T> operator *(Scalar<T> left, Scalar<T> right)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
<# if (supportedTypes[i].multiplicationOverride != null) { #>
                    return From(<#= supportedTypes[i].multiplicationOverride("left." + getPropertyName(supportedTypes[i].name), "right." + getPropertyName(supportedTypes[i].name)) #>);
<# } else { #>
                    return From(left.<#= getPropertyName(supportedTypes[i].name) #> * right.<#= getPropertyName(supportedTypes[i].name) #>);
<# } #>
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static Scalar<T> operator /(Scalar<T> left, Scalar<T> right)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
<# if (supportedTypes[i].canBeDivided) { #>
                    return From(left.<#= getPropertyName(supportedTypes[i].name) #> / right.<#= getPropertyName(supportedTypes[i].name) #>);
<# } else { #>
                    throw new Exception($"Division can't be performed on type <#= supportedTypes[i].type.ToString() #>.");
<# } #>
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static Scalar<T> operator -(Scalar<T> t)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
<# if (supportedTypes[i].hasAdditiveInverse) { #>
                    return From(-t.<#= getPropertyName(supportedTypes[i].name) #>);
<# } else { #>
                    throw new Exception("Type <<#= supportedTypes[i].type.ToString() #>> cannot be negated.");
<# } #>
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static Scalar<T> operator ~(Scalar<T> t)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
<# if (supportedTypes[i].canBeComplemented) { #>
<# if (supportedTypes[i].complementOverride != null) { #>
                    return From(<#= supportedTypes[i].complementOverride("t." + getPropertyName(supportedTypes[i].name)) #>);
<# } else { #>
                    return From(~t.<#= getPropertyName(supportedTypes[i].name) #>);
<# } #>
<# } else { #>
                    throw new Exception("Bitwise complement cannot be performed on type <#= supportedTypes[i].type.ToString() #>.");
<# } #>
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        #endregion

        #region Identity and Order

        public static bool operator ==(Scalar<T> left, Scalar<T> right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(Scalar<T> left, Scalar<T> right)
        {
            return !left.Equals(right);
        }

        public static bool operator <(Scalar<T> left, Scalar<T> right)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
<# if (supportedTypes[i].greaterThanOverride != null) { #>
                    return <#= supportedTypes[i].greaterThanOverride("left." + getPropertyName(supportedTypes[i].name), "right." + getPropertyName(supportedTypes[i].name)) #>;
<# } else { #>
                    return left.<#= getPropertyName(supportedTypes[i].name) #>.CompareTo(right.<#= getPropertyName(supportedTypes[i].name) #>) < 0;
<# } #>
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static bool operator >(Scalar<T> left, Scalar<T> right)
        {
            switch (scalarType)
            {
<# for (int i = 0; i < supportedTypes.Count; i++) { #>
                case ScalarType.<#= supportedTypes[i].name #>:
<# if (supportedTypes[i].greaterThanOverride != null) { #>
                    return <#= supportedTypes[i].greaterThanOverride("left." + getPropertyName(supportedTypes[i].name), "right." + getPropertyName(supportedTypes[i].name)) #>;
<# } else { #>
                    return left.<#= getPropertyName(supportedTypes[i].name) #>.CompareTo(right.<#= getPropertyName(supportedTypes[i].name) #>) > 0;
<# } #>
<# } #>
                default:
                    throw new Exception($"Unrecognized scalar type <{ scalarType }>");
            }
        }

        public static bool operator <=(Scalar<T> left, Scalar<T> right)
        {
            return (left < right) || (left == right);
        }

        public static bool operator >=(Scalar<T> left, Scalar<T> right)
        {
            return (left > right) || (left == right);
        }

        #endregion

        #endregion

        #region Implicit Conversion

<# for (int i = 0; i < supportedTypes.Count; i++) { #>
        public static implicit operator Scalar<T>(<#= supportedTypes[i].type.ToString() #> value)
        {
            return From(value);
        }
        public static implicit operator <#= supportedTypes[i].type.ToString() #>(Scalar<T> value)
        {
            if (scalarType == ScalarType.<#= supportedTypes[i].name #>)
                return value.<#= getPropertyName(supportedTypes[i].name) #>;
            return value.Cast<<#= supportedTypes[i].type.ToString() #>>().Value;
        }

<# } #>
        #endregion

        #region Interface Implementations

        public override string ToString()
        {
            return Value.ToString();
        }

        public override bool Equals(object obj)
        {
            if (obj is Scalar<T> sc)
                return Value.Equals(sc.Value);
            if (obj is T t)
                return Value.Equals(t);

            return false;
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public object Clone()
        {
            return new Scalar<T>(Value);
        }

        public bool Equals(Scalar<T> other)
        {
            return Value.Equals(other.Value);
        }

        #endregion
    }
}
<#+
public struct ScalarType
{
	public readonly Type type;
	public readonly string name;
	public readonly string zeroValue;// Will be used as a zero value
	public readonly string oneValue;// "1" for int, "1f" for float, "1.0" for double etc.
	public readonly bool hasAdditiveInverse;// false for unsigned types, true otherwise
	public readonly bool hasMultiplicativeInverse;// True for types without a decimal point like int, byte, long etc. False for decimal types float, double, decimal etc.
	public readonly bool canBeSubstracted;
	public readonly bool canBeDivided;
	public readonly Func<string, string, string> additionOverride;// assign this if the addition can't be performed normally with the + sign. It takes two variable names and returns a sentence that adds them.
	public readonly Func<string, string, string> multiplicationOverride;// assign this if the multiplication can't be performed normally with the * sign. It takes two variable names and returns a sentence that multiplies them.
	public readonly Func<string, string, string> greaterThanOverride;// assign this if the comparison can't be performed normally with the > sign. It takes two variable names and returns a sentence that compares them and returns that greatest.
	public readonly Func<string, string, string> lessThanOverride;// assign this if the comparison can't be performed normally with the > sign. It takes two variable names and returns a sentence that compares them and returns that greatest.
	public readonly bool canBeComplemented;
	public readonly Func<string, string> complementOverride;// assign this if the multiplication can't be performed normally with the + sign. It takes one variable and returns a sentence that performs bitwise complement on it.
    public readonly string algebraicStructreName;

	public ScalarType
	(
		Type type,
		string zeroValue,
		string oneValue,
		bool hasAdditiveInverse,
		bool hasMultiplicativeInverse,
		bool canBeSubstracted = true,
		bool canBeDivided = true,
		Func<string, string, string> additionOverride = null,
		Func<string, string, string> multiplicationOverride = null,
		Func<string, string, string> greaterThanOverride = null,
		Func<string, string, string> lessThanOverride = null,
		bool canBeComplemented = true,
		Func<string, string> complementOverride = null
	)
	{
		this.type = type;
		this.name = type.Name;
		this.zeroValue = zeroValue;
		this.oneValue = oneValue;
		this.hasAdditiveInverse = hasAdditiveInverse;
		this.hasMultiplicativeInverse = hasMultiplicativeInverse;
		this.canBeSubstracted = canBeSubstracted;
		this.canBeDivided = canBeDivided;
		this.additionOverride = additionOverride;
		this.multiplicationOverride = multiplicationOverride;
		this.greaterThanOverride = greaterThanOverride;
		this.lessThanOverride = lessThanOverride;
		this.canBeComplemented = canBeComplemented;
		this.complementOverride = complementOverride;

        if (hasMultiplicativeInverse)
            algebraicStructreName = "Field";
        else if (hasAdditiveInverse)
            algebraicStructreName = "Ring";
        else if (canBeSubstracted)
            algebraicStructreName = "Semiring";
        else if (canBeComplemented)
            algebraicStructreName = "BooleanAlgebra";
        else throw new Exception("abstract algebra is really fucking hard.");
	}
}
#>